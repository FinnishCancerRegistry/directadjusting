% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/direct_adjusting.R
\name{direct_adjusted_estimates}
\alias{direct_adjusted_estimates}
\title{Direct Adjusted Estimates}
\usage{
direct_adjusted_estimates(stats_dt, stat_col_nms, var_col_nms,
  stratum_col_nms = NULL, adjust_col_nms, conf_lvls, conf_methods,
  weights)
}
\arguments{
\item{stats_dt}{\code{[data.table]} (mandatory, no default)

a \code{data.table} containing estimates and variance estimates of statistics}

\item{stat_col_nms}{\code{[character]} (mandatory, no default)

names of columns in \code{stats_dt} containing estimates (statistics);
\code{NA} statistics values cause also \code{NA} confidence intervals}

\item{var_col_nms}{\code{[character]} (optional, default \code{NULL})
\itemize{
\item if \code{NULL}, no confidence intervals can (will) be computed
\item if \code{character} vector, names of columns in \code{stats_dt} containing variance
estimates of the statistics specified in \code{stat_col_nms} with one-to-one
correspondence; \code{NA} elements in \code{var_col_nms} cause no confidence
intervals to computed for those statistics;
\code{NA} variance estimates in \code{stats_dt} cause \code{NA} confidence intervals;
negative values cause an error; \code{Inf} values cause \code{c(-Inf, Inf)}
intervals with confidence interval method \code{"identity"}, etc.
}}

\item{stratum_col_nms}{\code{[NULL, character]} (optional, default \code{NULL})

names of columns in \code{stats_dt} by which statistics are stratified (and they
should be stratified by these columns after direct adjusting)}

\item{adjust_col_nms}{\code{[character]} (mandatory, no default)

names of columns in \code{stats_dt} by which statistics are currently stratified
and by which the statistics should be adjusted (e.g. \code{"agegroup"})}

\item{conf_lvls}{\code{[numeric]} (mandatory, default \code{0.95})

confidence levels for confidence intervals; you may specify each statistic
(see \code{stat_col_nms}) its own level by supplying a vector of values;
values other than between \code{(0, 1)} cause an error}

\item{conf_methods}{\code{[character]} (mandatory, default \code{"identity"})

method to compute confidence intervals; either one string (to be used for
all statistics) or a vector of strings, one for each element of
\code{stat_col_nms}; use \code{"none"} for statistics for which you do not want
confidence intervals to be calculated (or \code{NA} in \code{var_col_nms});
see \code{\link{confidence_intervals}} for supported methods}

\item{weights}{\code{[double, data.table, character]}

the weights need not sum to one as this is ensured internally; you may
supply weights in one of the following ways:
\itemize{
\item \code{double}: a vector of weights can be given when adjusting by exactly
one variable (e.g. age group); the length must match the number of unique
values in the adjusting variable
\item \code{data.table}: with one or more columns with names matching to those
variables that are used to adjust estimates, and one column named
\code{weight}; e.g. \code{data.table(agegroup = 1:3, weight = c(100, 500, 400))}
\item \code{character}: a string specifying one of the weighting schemas integrated
into this package; see \code{\link{integrated_weight_schemas}}; again
this is only allowed when you are adjusting by exactly one variable
}}
}
\description{
Compute direct adjusted estimates from a table of statistics.
}
\section{Weights}{


The weights are scaled internally to sum to one, but they need to be positive
numbers (or zero). The scalingis performed separately by each unique
combination of \code{stratum_col_nms} columns. This allows you to have e.g.
two hierarhical variables, one used for adjusting and one for stratifying
output (such as 18 age groups of 5 years for adjusting and 4 larger age
groups for stratifying output). See \strong{Examples}.
}

\section{Tabulation}{


Currently every pair of columns in \code{union(stratum_col_nms, adjust_col_nms)}
must be either
\itemize{
\item hierarhical: each level of B exists under exactly one level of A (or
converse); e.g. regions \code{c(1, 1, 2, 2)} and sub-regions \code{c(1, 2, 3, 4)};
sub-regions \code{c(1, 2, 2, 3)} would not be hierarchical
\item cross-joined: every level of B is repeated for every level of A; e.g.
sexes \code{c(1, 1, 2, 2)} and regions \code{c(1, 2, 1, 2)};
regions \code{c(1, 2, 2, 3)} would not be cross-joined
}

This ensures that adjusting will be performed properly, i.e. the weights
are merged and used as intended.
}

\examples{

# suppose we have poisson rates that we want to adjust for by age group.
# they are stratified by sex.
library("data.table")
set.seed(1337)

offsets <- rnorm(8, mean = 1000, sd = 100)
baseline <- 100
hrs_by_sex <- rep(1:2, each = 4)
hrs_by_ag <- rep(c(0.75, 0.90, 1.10, 1.25), times = 2)
counts <- rpois(8, baseline * hrs_by_sex * hrs_by_ag)

# raw estimates
my_stats <- data.table::data.table(
  sex = rep(1:2, each = 4),
  ag = rep(1:4, times = 2),
  e = counts / offsets,
  v = counts / (offsets ** 2)
)

# adjusted by age group
my_adj_stats <- direct_adjusted_estimates(
  stats_dt = my_stats,
  stat_col_nms = "e",
  var_col_nms = "v",
  conf_lvls = 0.95,
  conf_methods = "log",
  stratum_col_nms = "sex",
  adjust_col_nms = "ag",
  weights = c(200, 300, 400, 100)
)

# adjusted by smaller age groups, stratified by larger age groups
my_stats[, "ag2" := c(1,1, 2,2, 1,1, 2,2)]
my_adj_stats <- direct_adjusted_estimates(
  stats_dt = my_stats,
  stat_col_nms = "e",
  var_col_nms = "v",
  conf_lvls = 0.95,
  conf_methods = "log",
  stratum_col_nms = c("sex", "ag2"),
  adjust_col_nms = "ag",
  weights = c(200, 300, 400, 100)
)

# survival example; see help("survival.formula")
if (requireNamespace("survival", quietly = TRUE)) {
  library("survival")
  library("data.table")
  fit <- survfit(Surv(time, status) ~ x, data = aml)
  surv_stats <- summary(fit, times = 0:40)
  surv_dt <- data.table::data.table(
    x = surv_stats[["strata"]],
    time = surv_stats[["time"]],
    surv = surv_stats[["surv"]],
    var = surv_stats[["std.err"]] ** 2
  )
  surv_dt_adj <- direct_adjusted_estimates(
    stats_dt = surv_dt,
    stat_col_nms = "surv",
    var_col_nms = "var",
    conf_lvls = 0.95,
    conf_methods = "log-log",
    stratum_col_nms = "time",
    adjust_col_nms = "x",
    weights = c(600, 400)
  )
  print(surv_dt_adj, nrows = 10)
  matplot(
    y = surv_dt_adj[, .(surv, surv_lo, surv_hi)], 
    x = surv_dt_adj[["time"]], type = "s", col = 1, lty = 1,
    xlab = "time", ylab = "survival",
    main = "Survival with 95 \% CIs"
  )
}

}
