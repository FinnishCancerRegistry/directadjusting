% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/confidence_intervals.R
\name{confidence_intervals}
\alias{confidence_intervals}
\alias{delta_method_confidence_intervals}
\alias{bootstrap_confidence_intervals}
\title{Confidence Intervals}
\usage{
delta_method_confidence_intervals(
  statistics,
  variances,
  conf_lvl = 0.95,
  conf_method = "identity"
)

bootstrap_confidence_intervals(
  stats_dt,
  stat_col_nms,
  stratum_col_nms,
  conf_lvls,
  adjust_weight_col_nm = "weight",
  boot_arg_list = list(R = 1000),
  boot_ci_arg_list = list(type = "perc")
)
}
\arguments{
\item{statistics}{`[numeric]` (no default)

Statistics for which to calculate confidence intervals.}

\item{variances}{`[numeric]` (no default)

Variance estimates of `statistics` used to compute confidence intervals.}

\item{conf_lvl}{`[numeric]` (default `0.95`)

Confidence level of confidence intervals in `]0, 1[`.}

\item{conf_method}{`[character]` (default `"identity"`)

See **Details**.}
}
\description{
Functions to compute confidence intervals.
}
\section{Functions}{

**directadjusting::delta_method_confidence_intervals**

`directadjusting::delta_method_confidence_intervals` can be used to
compute confidence intervals using the delta method. The following steps
are performed:

- Collect mathematical expression `math` for computing the lower and upper
  end of the confidence interval based on `conf_method`.
  The following `conf_method` options have pre-determined math within
  this R package: `c("identity", "log", "log-log")`.
  Alternatively, `conf_method` can be quoted R expression --- see `?quote`.
  In that case it will be used as-is.
- Collect variables `est = statistics`, `var = variances`, and
  `std_err = sqrt(variance)` into a single `data.table`.
- Add `z = stats::qnorm(p = (1 - conf_lvl) / 2)` into the `data.table`.
  E.g. `z = -1.959964` with `conf_lvl = 0.95`.
- Evaluate the mathematical expression `math` such that the columns in the
  `data.table` are available in evaluation. This creates column `ci_lo`.
- Re-set `z = stats::qnorm(p = conf_lvl + (1 - conf_lvl) / 2)`.
  E.g. `z = 1.959964` with `conf_lvl = 0.95`.
- Evaluate `math` again. This yields `ci_hi`.
- Add attribute named `ci_meta` to the `data.table`.
  This attribute is a list which contains elements `conf_lvl`,
  `conf_method`, and `math`.
- Delete column `std_err`. Rename `est` to `statistic` and `var` to
  `variance`.
- Return `data.table` with columns
  `c("statistic", "variance", "ci_lo", "ci_hi")`.


**directadjusting::bootstrap_confidence_intervals**

`directadjusting::bootstrap_confidence_intervals` can be used to
compute confidence intervals using the bootstrap. The following steps are
performed:

- Collect a `data.table` containing the (non-duplicated) strata in
  `stats_dt` by `stratum_col_nms`.
- For each `stat_col_nms` element:
  + Set `boot_arg_list` elements `statistic`, `stype = "w"` and
    `boot_ci_arg_list[["conf"]] <- conf_lvls[i]` internally.
    `statistic` is a function which multiplies `adjust_weight_col_nm` with
    the bootstrap weight and returns the weighted average of the statistic
    in question.
  + Set `boot_arg_list[["data"]]` and
    `boot_ci_arg_list[["boot.out"]]` internally.
  + Call `boot::boot` and `boot::boot.ci` within each stratum.
  + Add the resulting confidence intervals into the output `data.table`.
- Returns a `data.table` with columns `stratum_col_nms` and for each `i`
  `stat_col_nms[i]`, `paste0(stat_col_nms[i], "_lo")`, and
  `paste0(stat_col_nms[i], "_hi")`.
}

\examples{

# directadjusting::delta_method_confidence_intervals
dt_1 <- directadjusting::delta_method_confidence_intervals(
  statistics = 0.0,
  variances = 0.1,
  conf_lvl = 0.95,
  conf_method = "identity"
)
# you can also supply your own math for computing the confidence intervals
dt_2 <- directadjusting::delta_method_confidence_intervals(
  statistics = 0.0,
  variances = 0.1,
  conf_lvl = 0.95,
  conf_method = quote(est + z * std_err)
)
stopifnot(
  all.equal(dt_1, dt_2, check.attributes = FALSE)
)
}
